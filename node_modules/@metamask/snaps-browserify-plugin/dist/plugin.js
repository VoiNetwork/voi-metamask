"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _SnapsBrowserifyTransform_data, _SnapsBrowserifyTransform_options;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapsBrowserifyTransform = void 0;
const stream_1 = require("stream");
const fs_1 = require("fs");
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const snap_utils_1 = require("@metamask/snap-utils");
const convert_source_map_1 = require("convert-source-map");
const TEMP_BUNDLE_PATH = path_1.default.join(os_1.default.tmpdir(), 'snaps-bundle.js');
/**
 * Run eval on the processed bundle and fix the manifest, if configured.
 *
 * @param options - The plugin options.
 * @param code - The code to eval, if the eval option is enabled.
 */
async function postBundle(options, code) {
    if (options.eval) {
        await fs_1.promises.mkdir(path_1.default.dirname(TEMP_BUNDLE_PATH), { recursive: true });
        await fs_1.promises.writeFile(TEMP_BUNDLE_PATH, code);
        await (0, snap_utils_1.evalBundle)(TEMP_BUNDLE_PATH)
            .catch((error) => {
            throw new Error(`Snap evaluation error: ${error.toString()}`);
        })
            .finally(() => fs_1.promises.unlink(TEMP_BUNDLE_PATH));
    }
    if (options.manifestPath) {
        const { errors, warnings } = await (0, snap_utils_1.checkManifest)(path_1.default.dirname(options.manifestPath), options.writeManifest, code);
        if (!options.writeManifest && errors.length > 0) {
            throw new Error(`Manifest Error: The manifest is invalid.\n${errors.join('\n')}`);
        }
        if (warnings.length > 0) {
            console.log('Manifest Warning: Validation of snap.manifest.json completed with warnings.');
            warnings.forEach((warning) => console.log(`Manifest Warning: ${warning}`));
        }
    }
}
/**
 * A transform stream which can be used in the Browserify pipeline. It accepts a
 * string input, which is post-processed and pushed to the output stream.
 */
class SnapsBrowserifyTransform extends stream_1.Transform {
    /**
     * Construct an instance of the transform stream.
     *
     * @param options - The post-processing options.
     * @param options.stripComments - Whether to strip comments. Defaults to `true`.
     * @param options.transformHtmlComments - Whether to transform HTML comments.
     * Defaults to `true`.
     */
    constructor(options = {}) {
        super();
        _SnapsBrowserifyTransform_data.set(this, []);
        _SnapsBrowserifyTransform_options.set(this, void 0);
        __classPrivateFieldSet(this, _SnapsBrowserifyTransform_options, Object.assign({}, options), "f");
    }
    /**
     * Takes a chunk of data and pushes it into an internal array, for later
     * processing.
     *
     * @param chunk - The chunk of data to transform.
     * @param _encoding - The encoding of the chunk.
     * @param callback - The callback to call when the chunk is processed.
     */
    _transform(chunk, _encoding, callback) {
        // Collects all the chunks into an array.
        __classPrivateFieldGet(this, _SnapsBrowserifyTransform_data, "f").push(chunk);
        callback();
    }
    /**
     * Takes the internal array of chunks and processes them. The processed code
     * is pushed to the output stream.
     *
     * @param callback - The callback to call when the stream is finished.
     */
    _flush(callback) {
        var _a, _b;
        // Merges all the chunks into a single string and processes it.
        const code = Buffer.concat(__classPrivateFieldGet(this, _SnapsBrowserifyTransform_data, "f")).toString('utf-8');
        // Browserify uses inline source maps, so we attempt to read it here, and
        // convert it to an object.
        const inputSourceMap = (_b = (_a = (0, convert_source_map_1.fromSource)(code)) === null || _a === void 0 ? void 0 : _a.toObject()) !== null && _b !== void 0 ? _b : undefined;
        const result = (0, snap_utils_1.postProcessBundle)(code, Object.assign(Object.assign({}, __classPrivateFieldGet(this, _SnapsBrowserifyTransform_options, "f")), { sourceMap: Boolean(inputSourceMap) && 'inline', inputSourceMap }));
        postBundle(__classPrivateFieldGet(this, _SnapsBrowserifyTransform_options, "f"), result.code)
            .catch((error) => {
            callback(error);
        })
            .finally(() => {
            this.push(result.code);
            callback();
        });
    }
}
exports.SnapsBrowserifyTransform = SnapsBrowserifyTransform;
_SnapsBrowserifyTransform_data = new WeakMap(), _SnapsBrowserifyTransform_options = new WeakMap();
/**
 * The Browserify plugin function. Can be passed to the Browserify `plugin`
 * function, or used by simply passing the package name to `plugin`.
 *
 * @param browserifyInstance - The Browserify instance.
 * @param options - The plugin options.
 * @param options.stripComments - Whether to strip comments. Defaults to `true`.
 * @param options.eval - Whether to evaluate the bundle to test SES
 * compatibility. Defaults to `true`.
 * @param options.manifestPath - The path to the manifest file. If provided,
 * the manifest will be validated. Defaults to
 * `process.cwd() + '/snap.manifest.json'`.
 * @param options.writeManifest - Whether to fix the manifest.
 * Defaults to `true`.
 */
function plugin(browserifyInstance, options) {
    const defaultOptions = Object.assign({ eval: true, manifestPath: path_1.default.join(process.cwd(), 'snap.manifest.json'), writeManifest: true }, options);
    // Pushes the transform stream at the end of Browserify's pipeline. This
    // ensures that the transform is run on the entire bundle.
    browserifyInstance.pipeline.push(new SnapsBrowserifyTransform(defaultOptions));
}
exports.default = plugin;
//# sourceMappingURL=plugin.js.map