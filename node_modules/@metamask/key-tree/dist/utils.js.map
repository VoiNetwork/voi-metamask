{"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { bytesToHex } from '@noble/hashes/utils';\nimport { base58check as scureBase58check } from '@scure/base';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport {\n  BIP32Node,\n  BIP44PurposeNodeToken,\n  ChangeHDPathString,\n  CoinTypeHDPathString,\n  CoinTypeToAddressTuple,\n  HardenedBIP32Node,\n  UnhardenedBIP32Node,\n} from './constants';\n\n/**\n * Gets a string representation of a BIP-44 path of depth 2, i.e.:\n * `m / 44' / coin_type'`\n *\n * For display purposes only.\n *\n * @param coin_type - The `coin_type` index to create a path visualization for.\n * @returns The visualization of the BIP-44 path for thte specified `coin_type`.\n */\nexport function getBIP44CoinTypePathString(\n  coin_type: number,\n): CoinTypeHDPathString {\n  return `m / ${BIP44PurposeNodeToken} / ${getUnhardenedBIP32NodeToken(\n    coin_type,\n  )}'`;\n}\n\ntype BIP44PathIndex = number | { index: number; hardened: boolean };\n\ntype BIP44PathIndices = {\n  coin_type: number;\n  account?: number;\n  change?: BIP44PathIndex;\n  address_index: BIP44PathIndex;\n};\n\nexport type CoinTypeToAddressIndices = Pick<\n  BIP44PathIndices,\n  'account' | 'change' | 'address_index'\n>;\n\n/**\n * Gets a string representation of a BIP-44 path of depth 4, i.e.:\n * `m / 44' / coin_type' / account' / change`\n *\n * For display purposes only.\n *\n * @param coinTypePath - The parent `coin_type` path.\n * @param coin_type - The `change` index to create a path visualization for.\n * @returns The visualization of the BIP-44 path for the specified `coin_type`\n * and `change` indices.\n */\nexport function getBIP44ChangePathString(\n  coinTypePath: CoinTypeHDPathString,\n  indices: Omit<CoinTypeToAddressIndices, 'address_index'>,\n): ChangeHDPathString {\n  return `${coinTypePath} / ${getHardenedBIP32NodeToken(\n    indices.account || 0,\n  )} / ${getBIP32NodeToken(indices.change || 0)}`;\n}\n\n/**\n * Gets a BIP-44 path tuple of the form `account' / change / address_index`,\n * which can be used to derive address keys together with a `coin_type` key.\n *\n * @param indices - The BIP-44 derivation index values.\n * @param indices.account - The `account` index value.\n * @param indices.change - The `change` index value.\n * @param indices.address_index - The `address_index` index value.\n * @returns The `account' / change / address_index` path corresponding to the\n * specified indices.\n */\nexport function getBIP44CoinTypeToAddressPathTuple({\n  account = 0,\n  change = 0,\n  address_index,\n}: CoinTypeToAddressIndices): CoinTypeToAddressTuple {\n  return [\n    getHardenedBIP32NodeToken(account),\n    getBIP32NodeToken(change),\n    getBIP32NodeToken(address_index),\n  ] as const;\n}\n\n/**\n * A hardened BIP-32 node token, e.g. `bip32:0'`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The hardened BIP-32 node token.\n */\nexport function getHardenedBIP32NodeToken(index: number): HardenedBIP32Node {\n  validateBIP32Index(index);\n  return `${getUnhardenedBIP32NodeToken(index)}'`;\n}\n\n/**\n * An unhardened BIP-32 node token, e.g. `bip32:0`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The unhardened BIP-32 node token.\n */\nexport function getUnhardenedBIP32NodeToken(\n  index: number,\n): UnhardenedBIP32Node {\n  validateBIP32Index(index);\n  return `bip32:${index}`;\n}\n\n/**\n * A hardened or unhardened BIP-32 node token, e.g. `bip32:0` or `bip32:0'`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The hardened or unhardened BIP-32 node token.\n */\nexport function getBIP32NodeToken(index: BIP44PathIndex): BIP32Node {\n  if (typeof index === 'number') {\n    return getUnhardenedBIP32NodeToken(index);\n  }\n\n  if (\n    !index ||\n    !Number.isInteger(index.index) ||\n    typeof index.hardened !== 'boolean'\n  ) {\n    throw new Error(\n      'Invalid BIP-32 index: Must be an object containing the index and whether it is hardened.',\n    );\n  }\n\n  if (index.hardened) {\n    return getHardenedBIP32NodeToken(index.index);\n  }\n\n  return getUnhardenedBIP32NodeToken(index.index);\n}\n\n/**\n * Validates that the index is a non-negative integer number. Throws an\n * error if validation fails.\n *\n * @param addressIndex - The index to validate.\n */\nexport function validateBIP32Index(addressIndex: number) {\n  if (!isValidBIP32Index(addressIndex)) {\n    throw new Error(`Invalid BIP-32 index: Must be a non-negative integer.`);\n  }\n}\n\n/**\n * @param index - The BIP-32 index to test.\n * @returns Whether the index is a non-negative integer number.\n */\nexport function isValidBIP32Index(index: number): boolean {\n  return isValidInteger(index);\n}\n\n/**\n * @param bip32Token - The token to test.\n * @returns Whether the token is hardened, i.e. ends with `'`.\n */\nexport function isHardened(bip32Token: string): boolean {\n  return bip32Token.endsWith(`'`);\n}\n\n/**\n * @param hexString - The hexadecimal string to strip.\n * @returns The hexadecimal string, without a `0x`-prefix, if any.\n */\nexport function stripHexPrefix(hexString: string): string {\n  return hexString.replace(/^0x/iu, '');\n}\n\n/**\n * Tests whether the specified string is a valid hexadecimal string. The string\n * may or may not be `0x`-prefixed, and the test is case-insensitive.\n *\n * @param hexString - The string to test.\n * @returns Whether the specified string is a valid hexadecimal string. The\n * string may or may not be `0x`-prefixed.\n */\nexport function isValidHexString(hexString: string): boolean {\n  return /^(?:0x)?[a-f0-9]+$/iu.test(hexString);\n}\n\n/**\n * @param hexString - The hexadecimal string to convert.\n * @returns The {@link Buffer} corresponding to the hexadecimal string.\n */\nexport function hexStringToBuffer(hexString: string | Buffer): Buffer {\n  if (Buffer.isBuffer(hexString)) {\n    return hexString;\n  }\n\n  if (typeof hexString !== 'string' || !isValidHexString(hexString)) {\n    throw new Error(`Invalid hex string: \"${hexString}\".`);\n  }\n\n  return Buffer.from(stripHexPrefix(hexString), 'hex');\n}\n\n/**\n * @param hexString - The hexadecimal string to convert.\n * @returns The {@link Buffer} corresponding to the hexadecimal string.\n */\nexport function nullableHexStringToBuffer(\n  hexString?: string | Buffer,\n): Buffer | undefined {\n  if (hexString) {\n    return hexStringToBuffer(hexString);\n  }\n\n  return undefined;\n}\n\n/**\n * Tests whether the specified {@link Buffer} is a valid BIP-32 key.\n * A valid buffer key is 64 bytes long and has at least one non-zero byte.\n *\n * @param buffer - The {@link Buffer} to test.\n * @param expectedLength - The expected length of the buffer.\n * @returns Whether the buffer represents a valid BIP-32 key.\n */\nexport function isValidBufferKey(\n  buffer: Buffer,\n  expectedLength: number,\n): boolean {\n  if (buffer.length !== expectedLength) {\n    return false;\n  }\n\n  for (const byte of buffer) {\n    if (byte !== 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Tests whether the specified number is a valid integer equal to or greater than 0.\n *\n * @param value - The number to test.\n * @returns Whether the number is a valid integer.\n */\nexport function isValidInteger(value: unknown): value is number {\n  return typeof value === 'number' && Number.isInteger(value) && value >= 0;\n}\n\n/**\n * Get a BigInt from a byte array.\n *\n * @param bytes - The byte array to get the BigInt for.\n * @returns The byte array as BigInt.\n */\nexport function bytesToNumber(bytes: Uint8Array): bigint {\n  return BigInt(`0x${bytesToHex(bytes)}`);\n}\n\n/**\n * Get a Buffer from a hexadecimal string or Buffer. Validates that the\n * length of the Buffer matches the specified length, and that the buffer\n * is not empty.\n *\n * @param value - The value to convert to a Buffer.\n * @param length - The length to validate the Buffer against.\n */\nexport function getBuffer(value: unknown, length: number): Buffer {\n  if (value instanceof Buffer) {\n    validateBuffer(value, length);\n\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    if (!isValidHexString(value)) {\n      throw new Error(\n        `Invalid value: Must be a valid hex string of length: ${length * 2}.`,\n      );\n    }\n\n    const buffer = hexStringToBuffer(value);\n    validateBuffer(buffer, length);\n\n    return buffer;\n  }\n\n  throw new Error(`Invalid value: Expected a Buffer or hexadecimal string.`);\n}\n\nfunction validateBuffer(\n  buffer: Buffer,\n  length: number,\n): asserts buffer is Buffer {\n  if (!isValidBufferKey(buffer, length)) {\n    throw new Error(`Invalid value: Must be a non-zero ${length}-byte buffer.`);\n  }\n}\n\nexport const decodeBase58check = (value: string): Buffer => {\n  const base58Check = scureBase58check(sha256);\n\n  try {\n    return Buffer.from(base58Check.decode(value));\n  } catch {\n    throw new Error(\n      `Invalid value: Value is not base58-encoded, or the checksum is invalid.`,\n    );\n  }\n};\n\nexport const encodeBase58check = (value: Buffer): string => {\n  const base58Check = scureBase58check(sha256);\n\n  return base58Check.encode(value);\n};\n\n/**\n * Get the fingerprint of a compressed public key as number.\n *\n * @param publicKey - The compressed public key to get the fingerprint for.\n */\nexport const getFingerprint = (publicKey: Buffer): number => {\n  if (!isValidBufferKey(publicKey, 33)) {\n    throw new Error(\n      `Invalid public key: The key must be a 33-byte, non-zero Buffer.`,\n    );\n  }\n\n  return Buffer.from(ripemd160(publicKey)).readUInt32BE(0);\n};\n"]}