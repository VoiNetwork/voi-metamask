"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validatePathSegment = exports.deriveKeyFromPath = void 0;
const constants_1 = require("./constants");
const derivers_1 = require("./derivers");
const SLIP10Node_1 = require("./SLIP10Node");
const BIP44Node_1 = require("./BIP44Node");
const BIP44CoinTypeNode_1 = require("./BIP44CoinTypeNode");
const curves_1 = require("./curves");
/**
 * Takes a full or partial HD path string and returns the key corresponding to
 * the given path, with the following constraints:
 *
 * - If the path starts with a BIP-32 node, a parent key must be provided.
 * - If the path starts with a BIP-39 node, a parent key must NOT be provided.
 * - The path cannot exceed 5 BIP-32 nodes in length, optionally preceded by
 *   a single BIP-39 node.
 *
 * WARNING: It is the consumer's responsibility to ensure that the path is valid
 * relative to its parent key.
 *
 * @param args
 * @param args.path - A full or partial HD path, e.g.:
 * bip39:SEED_PHRASE/bip32:44'/bip32:60'/bip32:0'/bip32:0/bip32:0
 *
 * BIP-39 seed phrases must be lowercase, space-delimited, and 12-24 words long.
 * @param args.node - The node to derive from.
 * @param args.depth - The depth of the segment.
 * @returns The derived key.
 */
async function deriveKeyFromPath(args) {
    const { path, depth = path.length } = args;
    const node = 'node' in args ? args.node : undefined;
    const curve = 'curve' in args ? args.curve : node === null || node === void 0 ? void 0 : node.curve;
    if (node &&
        !(node instanceof SLIP10Node_1.SLIP10Node) &&
        !(node instanceof BIP44Node_1.BIP44Node) &&
        !(node instanceof BIP44CoinTypeNode_1.BIP44CoinTypeNode)) {
        throw new Error('Invalid arguments: Node must be a SLIP-10 node or a BIP-44 node when provided.');
    }
    if (!curve) {
        throw new Error('Invalid arguments: Must specify either a parent node or curve.');
    }
    validatePathSegment(path, Boolean(node === null || node === void 0 ? void 0 : node.privateKey) || Boolean(node === null || node === void 0 ? void 0 : node.publicKey), depth);
    // derive through each part of path
    // `pathSegment` needs to be cast to `string[]` because `HDPathTuple.reduce()` doesn't work
    return await path.reduce(async (promise, pathNode) => {
        const derivedNode = await promise;
        const [pathType, pathPart] = pathNode.split(':');
        /* istanbul ignore if: should be impossible */
        if (!hasDeriver(pathType)) {
            throw new Error(`Unknown derivation type: "${pathType}"`);
        }
        const deriver = derivers_1.derivers[pathType];
        return await deriver.deriveChildKey({
            path: pathPart,
            node: derivedNode,
            curve: curves_1.getCurveByName(curve),
        });
    }, Promise.resolve(node));
}
exports.deriveKeyFromPath = deriveKeyFromPath;
/**
 * @param pathType
 */
function hasDeriver(pathType) {
    return pathType in derivers_1.derivers;
}
/**
 * The path segment must be one of the following:
 * - A lone BIP-32 path node
 * - A lone BIP-39 path node
 * - A multipath
 *
 * @param path - The path segment string to validate.
 * @param hasKey
 * @param depth
 */
function validatePathSegment(path, hasKey, depth) {
    if (path.length === 0) {
        throw new Error(`Invalid HD path segment: The segment must not be empty.`);
    }
    if (path.length - 1 > constants_1.MAX_BIP_44_DEPTH) {
        throw new Error(`Invalid HD path segment: The segment cannot exceed a 0-indexed depth of 5.`);
    }
    let startsWithBip39 = false;
    path.forEach((node, index) => {
        if (index === 0) {
            startsWithBip39 = constants_1.BIP_39_PATH_REGEX.test(node);
            if (!startsWithBip39 && !constants_1.BIP_32_PATH_REGEX.test(node)) {
                throw getMalformedError();
            }
        }
        else if (!constants_1.BIP_32_PATH_REGEX.test(node)) {
            throw getMalformedError();
        }
    });
    if (depth === constants_1.MIN_BIP_44_DEPTH && (!startsWithBip39 || path.length !== 1)) {
        throw new Error(`Invalid HD path segment: The segment must consist of a single BIP-39 node for depths of ${constants_1.MIN_BIP_44_DEPTH}. Received: "${path}".`);
    }
    if (!hasKey && !startsWithBip39) {
        throw new Error('Invalid derivation parameters: Must specify parent key if the first node of the path segment is not a BIP-39 node.');
    }
    if (hasKey && startsWithBip39) {
        throw new Error('Invalid derivation parameters: May not specify parent key if the path segment starts with a BIP-39 node.');
    }
}
exports.validatePathSegment = validatePathSegment;
function getMalformedError() {
    throw new Error('Invalid HD path segment: The path segment is malformed.');
}
//# sourceMappingURL=derivation.js.map