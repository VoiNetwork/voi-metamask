"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveChildNode = exports.validateParentFingerprint = exports.validateBIP32Depth = exports.SLIP10Node = void 0;
const constants_1 = require("./constants");
const curves_1 = require("./curves");
const derivation_1 = require("./derivation");
const bip32_1 = require("./derivers/bip32");
const utils_1 = require("./utils");
class SLIP10Node {
    constructor({ depth, parentFingerprint, index, chainCode, privateKey, publicKey, curve, }) {
        this.depth = depth;
        this.parentFingerprint = parentFingerprint;
        this.index = index;
        this.chainCodeBuffer = chainCode;
        this.privateKeyBuffer = privateKey;
        this.publicKeyBuffer = publicKey;
        this.curve = curve;
        Object.freeze(this);
    }
    /**
     * Wrapper of the {@link fromExtendedKey} function. Refer to that function
     * for documentation.
     *
     * @param json - The JSON representation of a SLIP-10 node.
     */
    static async fromJSON(json) {
        return SLIP10Node.fromExtendedKey(json);
    }
    /**
     * Create a new SLIP-10 node from a key and chain code. You must specify
     * either a private key or a public key. When specifying a private key,
     * the public key will be derived from the private key.
     *
     * All parameters are stringently validated, and an error is thrown if
     * validation fails.
     *
     * @param depth - The depth of the node.
     * @param parentFingerprint - The fingerprint of the parent key, or 0 if
     * the node is a master node.
     * @param index - The index of the node, or 0 if the node is a master node.
     * @param privateKey - The private key for the node.
     * @param publicKey - The public key for the node. If a private key is
     * specified, this parameter is ignored.
     * @param chainCode - The chain code for the node.
     * @param curve - The curve used by the node.
     */
    static async fromExtendedKey({ depth, parentFingerprint, index, privateKey, publicKey, chainCode, curve, }) {
        const chainCodeBuffer = utils_1.getBuffer(chainCode, constants_1.BUFFER_KEY_LENGTH);
        validateCurve(curve);
        validateBIP32Depth(depth);
        utils_1.validateBIP32Index(index);
        validateParentFingerprint(parentFingerprint);
        if (privateKey) {
            const privateKeyBuffer = utils_1.getBuffer(privateKey, constants_1.BUFFER_KEY_LENGTH);
            return new SLIP10Node({
                depth,
                parentFingerprint,
                index,
                chainCode: chainCodeBuffer,
                privateKey: privateKeyBuffer,
                publicKey: await curves_1.getCurveByName(curve).getPublicKey(privateKey),
                curve,
            });
        }
        if (publicKey) {
            const publicKeyBuffer = utils_1.getBuffer(publicKey, curves_1.getCurveByName(curve).publicKeyLength);
            return new SLIP10Node({
                depth,
                parentFingerprint,
                index,
                chainCode: chainCodeBuffer,
                publicKey: publicKeyBuffer,
                curve,
            });
        }
        throw new Error('Invalid options: Must provide either a private key or a public key.');
    }
    /**
     * Create a new SLIP-10 node from a derivation path. The derivation path
     * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of
     * the form `bip39:MNEMONIC`, where `MNEMONIC` is a space-separated list of
     * BIP-39 seed phrase words.
     *
     * All parameters are stringently validated, and an error is thrown if
     * validation fails.
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param derivationPath - The rooted HD tree path that will be used
     * to derive the key of this node.
     * @param curve - The curve used by the node.
     */
    static async fromDerivationPath({ derivationPath, curve, }) {
        validateCurve(curve);
        if (!derivationPath) {
            throw new Error('Invalid options: Must provide a derivation path.');
        }
        if (derivationPath.length === 0) {
            throw new Error('Invalid derivation path: May not specify an empty derivation path.');
        }
        return await derivation_1.deriveKeyFromPath({
            path: derivationPath,
            depth: derivationPath.length - 1,
            curve,
        });
    }
    get chainCode() {
        return this.chainCodeBuffer.toString('hex');
    }
    get privateKey() {
        var _a;
        return (_a = this.privateKeyBuffer) === null || _a === void 0 ? void 0 : _a.toString('hex');
    }
    get publicKey() {
        return this.publicKeyBuffer.toString('hex');
    }
    get compressedPublicKeyBuffer() {
        return curves_1.getCurveByName(this.curve).compressPublicKey(this.publicKeyBuffer);
    }
    get address() {
        if (this.curve !== 'secp256k1') {
            throw new Error('Unable to get address for this node: Only secp256k1 is supported.');
        }
        return `0x${bip32_1.publicKeyToEthAddress(this.publicKeyBuffer).toString('hex')}`;
    }
    get fingerprint() {
        return utils_1.getFingerprint(this.compressedPublicKeyBuffer);
    }
    /**
     * Returns a neutered version of this node, i.e. a node without a private key.
     */
    neuter() {
        return new SLIP10Node({
            depth: this.depth,
            parentFingerprint: this.parentFingerprint,
            index: this.index,
            chainCode: this.chainCodeBuffer,
            publicKey: this.publicKeyBuffer,
            curve: this.curve,
        });
    }
    /**
     * Derives a child of the key contains be this node and returns a new
     * {@link SLIP10Node} containing the child key.
     *
     * The specified path must be a valid HD path from this node, per SLIP-10.
     *
     * @param path - The partial (non-rooted) SLIP-10 HD tree path will be used
     * to derive a child key from the parent key contained within this node.
     * @returns The {@link SLIP10Node} corresponding to the derived child key.
     */
    async derive(path) {
        return await deriveChildNode({
            path,
            node: this,
        });
    }
    // This is documented in the interface of this class.
    toJSON() {
        return {
            depth: this.depth,
            parentFingerprint: this.parentFingerprint,
            index: this.index,
            curve: this.curve,
            privateKey: this.privateKey,
            publicKey: this.publicKey,
            chainCode: this.chainCode,
        };
    }
}
exports.SLIP10Node = SLIP10Node;
/**
 * Validates the curve name.
 *
 * @param curveName - The name of the curve to validate.
 */
function validateCurve(curveName) {
    if (!curveName || typeof curveName !== 'string') {
        throw new Error('Invalid curve: Must specify a curve.');
    }
    if (!Object.keys(curves_1.curves).includes(curveName)) {
        throw new Error(`Invalid curve: Only the following curves are supported: ${Object.keys(curves_1.curves).join(', ')}.`);
    }
}
/**
 * Validates a BIP-32 path depth. Effectively, asserts that the depth is an
 * integer `number`. Throws an error if validation fails.
 *
 * @param depth - The depth to validate.
 */
function validateBIP32Depth(depth) {
    if (!utils_1.isValidInteger(depth)) {
        throw new Error(`Invalid HD tree path depth: The depth must be a positive integer. Received: "${depth}".`);
    }
}
exports.validateBIP32Depth = validateBIP32Depth;
/**
 * Validates a BIP-32 parent fingerprint. Effectively, asserts that the fingerprint is an
 * integer `number`. Throws an error if validation fails.
 *
 * @param parentFingerprint - The parent fingerprint to validate.
 */
function validateParentFingerprint(parentFingerprint) {
    if (!utils_1.isValidInteger(parentFingerprint)) {
        throw new Error(`Invalid parent fingerprint: The fingerprint must be a positive integer. Received: "${parentFingerprint}".`);
    }
}
exports.validateParentFingerprint = validateParentFingerprint;
/**
 * Derives a child key from the given parent key.
 *
 * @param node - The node to derive from.
 * @param path - The path to the child node / key.
 * @returns The derived key and depth.
 */
async function deriveChildNode({ path, node, }) {
    if (path.length === 0) {
        throw new Error('Invalid HD tree derivation path: Deriving a path of length 0 is not defined.');
    }
    // Note that we do not subtract 1 from the length of the path to the child,
    // unlike when we calculate the depth of a rooted path.
    const newDepth = node.depth + path.length;
    validateBIP32Depth(newDepth);
    return await derivation_1.deriveKeyFromPath({
        path,
        node,
        depth: newDepth,
    });
}
exports.deriveChildNode = deriveChildNode;
//# sourceMappingURL=SLIP10Node.js.map