"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BIP44CoinTypeNode_node;
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBIP44AddressKeyDeriver = exports.deriveBIP44AddressKey = exports.BIP44CoinTypeNode = exports.BIP_44_COIN_TYPE_DEPTH = void 0;
const constants_1 = require("./constants");
const BIP44Node_1 = require("./BIP44Node");
const utils_1 = require("./utils");
const SLIP10Node_1 = require("./SLIP10Node");
exports.BIP_44_COIN_TYPE_DEPTH = 2;
/**
 * A wrapper object for BIP-44 `coin_type` keys. `coin_type` is the index
 * specifying the protocol for which deeper keys are intended. For the
 * authoritative list of coin types, please see
 * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 */
class BIP44CoinTypeNode {
    constructor(node, coin_type) {
        _BIP44CoinTypeNode_node.set(this, void 0);
        __classPrivateFieldSet(this, _BIP44CoinTypeNode_node, node, "f");
        this.coin_type = coin_type;
        this.path = utils_1.getBIP44CoinTypePathString(coin_type);
        Object.freeze(this);
    }
    /**
     * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
     * specifying the protocol for which deeper keys are intended. For the
     * authoritative list of coin types, please see
     * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param json - The {@link JsonBIP44Node} for the key of this node.
     * @param coin_type - The coin_type index of this node. Must be a non-negative
     * integer.
     */
    static async fromJSON(json, coin_type) {
        validateCoinType(coin_type);
        validateCoinTypeNodeDepth(json.depth);
        const node = await BIP44Node_1.BIP44Node.fromExtendedKey({
            depth: json.depth,
            index: json.index,
            parentFingerprint: json.parentFingerprint,
            chainCode: utils_1.hexStringToBuffer(json.chainCode),
            privateKey: utils_1.nullableHexStringToBuffer(json.privateKey),
            publicKey: utils_1.hexStringToBuffer(json.publicKey),
        });
        return new BIP44CoinTypeNode(node, coin_type);
    }
    /**
     * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
     * specifying the protocol for which deeper keys are intended. For the
     * authoritative list of coin types, please see
     * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param derivationPath - The derivation path for the key of this node.
     */
    static async fromDerivationPath(derivationPath) {
        validateCoinTypeNodeDepth(derivationPath.length - 1);
        const node = await BIP44Node_1.BIP44Node.fromDerivationPath({
            derivationPath,
        });
        // Split the bip32 string token and extract the coin_type index
        const coinType = Number.parseInt(derivationPath[exports.BIP_44_COIN_TYPE_DEPTH].split(':')[1].replace(`'`, ''), 10);
        return new BIP44CoinTypeNode(node, coinType);
    }
    /**
     * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
     * specifying the protocol for which deeper keys are intended. For the
     * authoritative list of coin types, please see
     * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param node - The {@link BIP44Node} for the key of this node.
     * @param coin_type - The coin_type index of this node. Must be a non-negative
     * integer.
     */
    static async fromNode(node, coin_type) {
        if (!(node instanceof BIP44Node_1.BIP44Node)) {
            throw new Error('Invalid node: Expected an instance of BIP44Node.');
        }
        validateCoinType(coin_type);
        validateCoinTypeNodeDepth(node.depth);
        return new BIP44CoinTypeNode(node, coin_type);
    }
    get depth() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").depth;
    }
    get privateKeyBuffer() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").privateKeyBuffer;
    }
    get publicKeyBuffer() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").publicKeyBuffer;
    }
    get chainCodeBuffer() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").chainCodeBuffer;
    }
    get privateKey() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").privateKey;
    }
    get publicKey() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").publicKey;
    }
    get compressedPublicKeyBuffer() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").compressedPublicKeyBuffer;
    }
    get chainCode() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").chainCode;
    }
    get address() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").address;
    }
    get parentFingerprint() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").parentFingerprint;
    }
    get fingerprint() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").fingerprint;
    }
    get index() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").index;
    }
    get curve() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").curve;
    }
    get extendedKey() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").extendedKey;
    }
    /**
     * Derives a BIP-44 `address_index` key corresponding to the path of this
     * node and the specified `account`, `change`, and `address_index` values.
     * `address_index` keys are normally the keys used to generate user account
     * addresses.
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param indices - The BIP-44 index values to use in key derivation.
     * @param indices.account - The `account` index. Default: `0`
     * @param indices.change - The `change` index. Default: `0`
     * @param indices.address_index - The `address_index` index.
     * @returns
     */
    async deriveBIP44AddressKey({ account = 0, change = 0, address_index, }) {
        return await __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").derive(utils_1.getBIP44CoinTypeToAddressPathTuple({ account, change, address_index }));
    }
    toJSON() {
        return Object.assign(Object.assign({}, __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").toJSON()), { coin_type: this.coin_type, path: this.path });
    }
}
exports.BIP44CoinTypeNode = BIP44CoinTypeNode;
_BIP44CoinTypeNode_node = new WeakMap();
/**
 * Validates the depth of a `coin_type` node. Simply, ensures that it is the
 * number `2`. An error is thrown if validation fails.
 *
 * @param depth - The depth to validate.
 */
function validateCoinTypeNodeDepth(depth) {
    if (depth !== exports.BIP_44_COIN_TYPE_DEPTH) {
        throw new Error(`Invalid depth: Coin type nodes must be of depth ${exports.BIP_44_COIN_TYPE_DEPTH}. Received: "${depth}"`);
    }
}
/**
 * Validates that the coin type is a non-negative integer number. An error is
 * thrown if validation fails.
 *
 * @param coin_type - The coin type to validate.
 */
function validateCoinType(coin_type) {
    if (typeof coin_type !== 'number' ||
        !Number.isInteger(coin_type) ||
        coin_type < 0) {
        throw new Error('Invalid coin type: The specified coin type must be a non-negative integer number.');
    }
}
/**
 * Derives a BIP-44 address key corresponding to the specified derivation path,
 * given either by a {@link BIP44CoinTypeNode} or derivation path tuple.
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 * @param parentKeyOrNode - The `coin_type` parent key to derive from.
 * @param indices - The `account`, `change`, and `address_index` used for
 * derivation.
 * @returns The derived `address_index` key for the specified derivation path.
 */
async function deriveBIP44AddressKey(parentKeyOrNode, { account = 0, change = 0, address_index }) {
    const path = utils_1.getBIP44CoinTypeToAddressPathTuple({
        account,
        change,
        address_index,
    });
    const node = await getNode(parentKeyOrNode);
    const childNode = await SLIP10Node_1.deriveChildNode({
        path,
        node,
    });
    return new BIP44Node_1.BIP44Node(childNode);
}
exports.deriveBIP44AddressKey = deriveBIP44AddressKey;
/**
 * Creates a function that derives BIP-44 address keys corresponding to the
 * specified derivation path, given either by a {@link BIP44CoinTypeNode} or
 * derivation path tuple.
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 * @param node - The {@link BIP44CoinTypeNode} to derive address keys from.
 * This node contains a BIP-44 key of depth 2, `coin_type`.
 * @param accountAndChangeIndices - The `account` and `change` indices that
 * will be used to derive addresses.
 * @returns The deriver function for the derivation path specified by the
 * `coin_type` node, `account`, and `change` indices.
 */
async function getBIP44AddressKeyDeriver(node, accountAndChangeIndices) {
    const { account = 0, change = 0 } = accountAndChangeIndices || {};
    const actualNode = await getNode(node);
    const accountNode = utils_1.getHardenedBIP32NodeToken(account);
    const changeNode = utils_1.getBIP32NodeToken(change);
    const bip44AddressKeyDeriver = async (address_index, isHardened = false) => {
        const slip10Node = await SLIP10Node_1.deriveChildNode({
            path: [
                accountNode,
                changeNode,
                isHardened
                    ? utils_1.getHardenedBIP32NodeToken(address_index)
                    : utils_1.getUnhardenedBIP32NodeToken(address_index),
            ],
            node: actualNode,
        });
        return new BIP44Node_1.BIP44Node(slip10Node);
    };
    bip44AddressKeyDeriver.coin_type = actualNode.coin_type;
    bip44AddressKeyDeriver.path = utils_1.getBIP44ChangePathString(actualNode.path, {
        account,
        change,
    });
    Object.freeze(bip44AddressKeyDeriver);
    return bip44AddressKeyDeriver;
}
exports.getBIP44AddressKeyDeriver = getBIP44AddressKeyDeriver;
/**
 * Get a BIP-44 coin type node from a JSON node or extended key string. If an existing coin type
 * node is provided, the same node is returned.
 *
 * The depth of the node is validated to be a valid coin type node.
 *
 * @param node - A BIP-44 coin type node, JSON node or extended key.
 */
async function getNode(node) {
    if (node instanceof BIP44CoinTypeNode) {
        validateCoinTypeNodeDepth(node.depth);
        return node;
    }
    if (typeof node === 'string') {
        const bip44Node = await BIP44Node_1.BIP44Node.fromExtendedKey(node);
        const coinTypeNode = await BIP44CoinTypeNode.fromNode(bip44Node, bip44Node.index - constants_1.BIP_32_HARDENED_OFFSET);
        validateCoinTypeNodeDepth(coinTypeNode.depth);
        return coinTypeNode;
    }
    return BIP44CoinTypeNode.fromJSON(node, node.coin_type);
}
//# sourceMappingURL=BIP44CoinTypeNode.js.map