"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFingerprint = exports.encodeBase58check = exports.decodeBase58check = exports.getBytes = exports.isValidInteger = exports.isValidBytesKey = exports.nullableHexStringToBytes = exports.hexStringToBytes = exports.isHardened = exports.isValidBIP32Index = exports.validateBIP32Index = exports.getBIP32NodeToken = exports.getUnhardenedBIP32NodeToken = exports.getHardenedBIP32NodeToken = exports.getBIP44CoinTypeToAddressPathTuple = exports.getBIP44ChangePathString = exports.getBIP44CoinTypePathString = void 0;
const base_1 = require("@scure/base");
const sha256_1 = require("@noble/hashes/sha256");
const ripemd160_1 = require("@noble/hashes/ripemd160");
const utils_1 = require("@metamask/utils");
const constants_1 = require("./constants");
/**
 * Gets a string representation of a BIP-44 path of depth 2, i.e.:
 * `m / 44' / coin_type'`
 *
 * For display purposes only.
 *
 * @param coin_type - The `coin_type` index to create a path visualization for.
 * @returns The visualization of the BIP-44 path for thte specified `coin_type`.
 */
function getBIP44CoinTypePathString(coin_type) {
    return `m / ${constants_1.BIP44PurposeNodeToken} / ${getHardenedBIP32NodeToken(coin_type)}`;
}
exports.getBIP44CoinTypePathString = getBIP44CoinTypePathString;
/**
 * Gets a string representation of a BIP-44 path of depth 4, i.e.:
 * `m / 44' / coin_type' / account' / change`
 *
 * For display purposes only.
 *
 * @param coinTypePath - The parent `coin_type` path.
 * @param indices - The `account` and `change` index to create a path visualization for.
 * @returns The visualization of the BIP-44 path for the specified `coin_type`
 * and `change` indices.
 */
function getBIP44ChangePathString(coinTypePath, indices) {
    return `${coinTypePath} / ${getHardenedBIP32NodeToken(indices.account || 0)} / ${getBIP32NodeToken(indices.change || 0)}`;
}
exports.getBIP44ChangePathString = getBIP44ChangePathString;
/**
 * Gets a BIP-44 path tuple of the form `account' / change / address_index`,
 * which can be used to derive address keys together with a `coin_type` key.
 *
 * @param indices - The BIP-44 derivation index values.
 * @param indices.account - The `account` index value.
 * @param indices.change - The `change` index value.
 * @param indices.address_index - The `address_index` index value.
 * @returns The `account' / change / address_index` path corresponding to the
 * specified indices.
 */
function getBIP44CoinTypeToAddressPathTuple({ account = 0, change = 0, address_index, }) {
    return [
        getHardenedBIP32NodeToken(account),
        getBIP32NodeToken(change),
        getBIP32NodeToken(address_index),
    ];
}
exports.getBIP44CoinTypeToAddressPathTuple = getBIP44CoinTypeToAddressPathTuple;
/**
 * A hardened BIP-32 node token, e.g. `bip32:0'`.
 * Validates that the index is a non-negative integer number, and throws an
 * error if validation fails.
 *
 * @param index - The index of the node.
 * @returns The hardened BIP-32 node token.
 */
function getHardenedBIP32NodeToken(index) {
    validateBIP32Index(index);
    return `${getUnhardenedBIP32NodeToken(index)}'`;
}
exports.getHardenedBIP32NodeToken = getHardenedBIP32NodeToken;
/**
 * An unhardened BIP-32 node token, e.g. `bip32:0`.
 * Validates that the index is a non-negative integer number, and throws an
 * error if validation fails.
 *
 * @param index - The index of the node.
 * @returns The unhardened BIP-32 node token.
 */
function getUnhardenedBIP32NodeToken(index) {
    validateBIP32Index(index);
    return `bip32:${index}`;
}
exports.getUnhardenedBIP32NodeToken = getUnhardenedBIP32NodeToken;
/**
 * A hardened or unhardened BIP-32 node token, e.g. `bip32:0` or `bip32:0'`.
 * Validates that the index is a non-negative integer number, and throws an
 * error if validation fails.
 *
 * @param index - The index of the node.
 * @returns The hardened or unhardened BIP-32 node token.
 */
function getBIP32NodeToken(index) {
    if (typeof index === 'number') {
        return getUnhardenedBIP32NodeToken(index);
    }
    if (!index ||
        !Number.isInteger(index.index) ||
        typeof index.hardened !== 'boolean') {
        throw new Error('Invalid BIP-32 index: Must be an object containing the index and whether it is hardened.');
    }
    if (index.hardened) {
        return getHardenedBIP32NodeToken(index.index);
    }
    return getUnhardenedBIP32NodeToken(index.index);
}
exports.getBIP32NodeToken = getBIP32NodeToken;
/**
 * Validates that the index is a non-negative integer number. Throws an
 * error if validation fails.
 *
 * @param addressIndex - The index to validate.
 */
function validateBIP32Index(addressIndex) {
    if (!isValidBIP32Index(addressIndex)) {
        throw new Error(`Invalid BIP-32 index: Must be a non-negative integer.`);
    }
}
exports.validateBIP32Index = validateBIP32Index;
/**
 * @param index - The BIP-32 index to test.
 * @returns Whether the index is a non-negative integer number.
 */
function isValidBIP32Index(index) {
    return isValidInteger(index);
}
exports.isValidBIP32Index = isValidBIP32Index;
/**
 * @param bip32Token - The token to test.
 * @returns Whether the token is hardened, i.e. ends with `'`.
 */
function isHardened(bip32Token) {
    return bip32Token.endsWith(`'`);
}
exports.isHardened = isHardened;
/**
 * @param hexString - The hexadecimal string to convert.
 * @returns The `Uint8Array` corresponding to the hexadecimal string.
 */
function hexStringToBytes(hexString) {
    if (hexString instanceof Uint8Array) {
        return hexString;
    }
    return (0, utils_1.hexToBytes)(hexString);
}
exports.hexStringToBytes = hexStringToBytes;
/**
 * @param hexString - The hexadecimal string to convert.
 * @returns The `Uint8Array` corresponding to the hexadecimal string.
 */
function nullableHexStringToBytes(hexString) {
    if (hexString !== undefined) {
        return hexStringToBytes(hexString);
    }
    return undefined;
}
exports.nullableHexStringToBytes = nullableHexStringToBytes;
/**
 * Tests whether the specified `Uint8Array` is a valid BIP-32 key.
 * A valid bytes key is 64 bytes long and has at least one non-zero byte.
 *
 * @param bytes - The `Uint8Array` to test.
 * @param expectedLength - The expected length of the Uint8Array.
 * @returns Whether the Uint8Array represents a valid BIP-32 key.
 */
function isValidBytesKey(bytes, expectedLength) {
    if (bytes.length !== expectedLength) {
        return false;
    }
    for (const byte of bytes) {
        if (byte !== 0) {
            return true;
        }
    }
    return false;
}
exports.isValidBytesKey = isValidBytesKey;
/**
 * Tests whether the specified number is a valid integer equal to or greater than 0.
 *
 * @param value - The number to test.
 * @returns Whether the number is a valid integer.
 */
function isValidInteger(value) {
    return typeof value === 'number' && Number.isInteger(value) && value >= 0;
}
exports.isValidInteger = isValidInteger;
/**
 * Get a `Uint8Array` from a hexadecimal string or `Uint8Array`. Validates that the
 * length of the `Uint8Array` matches the specified length, and that the `Uint8Array`
 * is not empty.
 *
 * @param value - The value to convert to a `Uint8Array`.
 * @param length - The length to validate the `Uint8Array` against.
 */
function getBytes(value, length) {
    if (value instanceof Uint8Array) {
        validateBytes(value, length);
        return value;
    }
    if (typeof value === 'string') {
        const bytes = (0, utils_1.hexToBytes)(value);
        validateBytes(bytes, length);
        return bytes;
    }
    throw new Error(`Invalid value: Expected an instance of Uint8Array or hexadecimal string.`);
}
exports.getBytes = getBytes;
function validateBytes(bytes, length) {
    if (!isValidBytesKey(bytes, length)) {
        throw new Error(`Invalid value: Must be a non-zero ${length}-byte byte array.`);
    }
}
const decodeBase58check = (value) => {
    const base58Check = (0, base_1.base58check)(sha256_1.sha256);
    try {
        return base58Check.decode(value);
    }
    catch (_a) {
        throw new Error(`Invalid value: Value is not base58-encoded, or the checksum is invalid.`);
    }
};
exports.decodeBase58check = decodeBase58check;
const encodeBase58check = (value) => {
    const base58Check = (0, base_1.base58check)(sha256_1.sha256);
    return base58Check.encode(value);
};
exports.encodeBase58check = encodeBase58check;
/**
 * Get the fingerprint of a compressed public key as number.
 *
 * @param publicKey - The compressed public key to get the fingerprint for.
 */
const getFingerprint = (publicKey) => {
    if (!isValidBytesKey(publicKey, 33)) {
        throw new Error(`Invalid public key: The key must be a 33-byte, non-zero byte array.`);
    }
    const bytes = (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(publicKey));
    const view = (0, utils_1.createDataView)(bytes);
    return view.getUint32(0, false);
};
exports.getFingerprint = getFingerprint;
//# sourceMappingURL=utils.js.map