"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBip39KeyFromSeed = exports.deriveChildKey = exports.bip39MnemonicToMultipath = void 0;
const bip39_1 = require("@scure/bip39");
const hmac_1 = require("@noble/hashes/hmac");
const sha512_1 = require("@noble/hashes/sha512");
const curves_1 = require("../curves");
const SLIP10Node_1 = require("../SLIP10Node");
/**
 * @param mnemonic
 */
function bip39MnemonicToMultipath(mnemonic) {
    return `bip39:${mnemonic.toLowerCase().trim()}`;
}
exports.bip39MnemonicToMultipath = bip39MnemonicToMultipath;
// this creates a child key using bip39, ignoring the parent key
/**
 * @param pathPart
 * @param curve
 */
async function deriveChildKey({ path, curve, }) {
    return createBip39KeyFromSeed(Buffer.from(bip39_1.mnemonicToSeedSync(path)), curve);
}
exports.deriveChildKey = deriveChildKey;
/**
 * @param seed - The cryptographic seed bytes.
 * @param curve - The curve to use.
 * @returns An object containing the corresponding BIP-39 master key and chain code.
 */
async function createBip39KeyFromSeed(seed, curve = curves_1.secp256k1) {
    const key = Buffer.from(hmac_1.hmac(sha512_1.sha512, curve.secret, seed));
    const privateKey = key.slice(0, 32);
    const chainCode = key.slice(32);
    return SLIP10Node_1.SLIP10Node.fromExtendedKey({
        privateKey,
        chainCode,
        depth: 0,
        parentFingerprint: 0,
        index: 0,
        curve: curve.name,
    });
}
exports.createBip39KeyFromSeed = createBip39KeyFromSeed;
//# sourceMappingURL=bip39.js.map