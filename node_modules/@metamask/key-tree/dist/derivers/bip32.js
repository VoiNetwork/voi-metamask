"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.privateAdd = exports.deriveChildKey = exports.publicKeyToEthAddress = exports.privateKeyToEthAddress = void 0;
const sha3_1 = require("@noble/hashes/sha3");
const hmac_1 = require("@noble/hashes/hmac");
const sha512_1 = require("@noble/hashes/sha512");
const utils_1 = require("@metamask/utils");
const constants_1 = require("../constants");
const utils_2 = require("../utils");
const curves_1 = require("../curves");
const SLIP10Node_1 = require("../SLIP10Node");
/**
 * Converts a BIP-32 private key to an Ethereum address.
 *
 * **WARNING:** Only validates that the key is non-zero and of the correct
 * length. It is the consumer's responsibility to ensure that the specified
 * key is a valid BIP-44 Ethereum `address_index` key.
 *
 * @param key - The `address_index` private key bytes to convert to an Ethereum
 * address.
 * @returns The Ethereum address corresponding to the given key.
 */
function privateKeyToEthAddress(key) {
    (0, utils_1.assert)(key instanceof Uint8Array && (0, utils_2.isValidBytesKey)(key, constants_1.BYTES_KEY_LENGTH), 'Invalid key: The key must be a 32-byte, non-zero Uint8Array.');
    const publicKey = curves_1.secp256k1.getPublicKey(key, false);
    return publicKeyToEthAddress(publicKey);
}
exports.privateKeyToEthAddress = privateKeyToEthAddress;
/**
 * Converts a BIP-32 public key to an Ethereum address.
 *
 * **WARNING:** Only validates that the key is non-zero and of the correct
 * length. It is the consumer's responsibility to ensure that the specified
 * key is a valid BIP-44 Ethereum `address_index` key.
 *
 * @param key - The `address_index` public key bytes to convert to an Ethereum
 * address.
 * @returns The Ethereum address corresponding to the given key.
 */
function publicKeyToEthAddress(key) {
    (0, utils_1.assert)(key instanceof Uint8Array &&
        (0, utils_2.isValidBytesKey)(key, curves_1.secp256k1.publicKeyLength), 'Invalid key: The key must be a 65-byte, non-zero Uint8Array.');
    return (0, sha3_1.keccak_256)(key.slice(1)).slice(-20);
}
exports.publicKeyToEthAddress = publicKeyToEthAddress;
/**
 * Derive a BIP-32 child key with a given path from a parent key.
 *
 * @param path - The derivation path part to derive.
 * @param node - The node to derive from.
 * @param curve - The curve to use for derivation.
 * @returns A tuple containing the derived private key, public key and chain
 * code.
 */
async function deriveChildKey({ path, node, curve = curves_1.secp256k1, }) {
    const isHardened = path.includes(`'`);
    if (!isHardened && !curve.deriveUnhardenedKeys) {
        throw new Error(`Invalid path: Cannot derive unhardened child keys with ${curve.name}.`);
    }
    if (!node) {
        throw new Error('Invalid parameters: Must specify a node to derive from.');
    }
    if (isHardened && !node.privateKey) {
        throw new Error('Invalid parameters: Cannot derive hardened child keys without a private key.');
    }
    const indexPart = path.split(`'`)[0];
    const childIndex = parseInt(indexPart, 10);
    if (!/^\d+$/u.test(indexPart) ||
        !Number.isInteger(childIndex) ||
        childIndex < 0 ||
        childIndex >= constants_1.BIP_32_HARDENED_OFFSET) {
        throw new Error(`Invalid BIP-32 index: The index must be a non-negative decimal integer less than ${constants_1.BIP_32_HARDENED_OFFSET}.`);
    }
    if (node.privateKeyBytes) {
        const secretExtension = await deriveSecretExtension({
            privateKey: node.privateKeyBytes,
            childIndex,
            isHardened,
            curve,
        });
        const { privateKey, chainCode } = await generateKey({
            privateKey: node.privateKeyBytes,
            chainCode: node.chainCodeBytes,
            secretExtension,
            curve,
        });
        return SLIP10Node_1.SLIP10Node.fromExtendedKey({
            privateKey,
            chainCode,
            depth: node.depth + 1,
            masterFingerprint: node.masterFingerprint,
            parentFingerprint: node.fingerprint,
            index: childIndex + (isHardened ? constants_1.BIP_32_HARDENED_OFFSET : 0),
            curve: curve.name,
        });
    }
    const publicExtension = await derivePublicExtension({
        parentPublicKey: node.compressedPublicKeyBytes,
        childIndex,
    });
    const { publicKey, chainCode } = generatePublicKey({
        publicKey: node.compressedPublicKeyBytes,
        chainCode: node.chainCodeBytes,
        publicExtension,
        curve,
    });
    return SLIP10Node_1.SLIP10Node.fromExtendedKey({
        publicKey,
        chainCode,
        depth: node.depth + 1,
        masterFingerprint: node.masterFingerprint,
        parentFingerprint: node.fingerprint,
        index: childIndex,
        curve: curve.name,
    });
}
exports.deriveChildKey = deriveChildKey;
// the bip32 secret extension is created from the parent private or public key and the child index
/**
 * @param options
 * @param options.privateKey
 * @param options.childIndex
 * @param options.isHardened
 */
async function deriveSecretExtension({ privateKey, childIndex, isHardened, curve, }) {
    if (isHardened) {
        // Hardened child
        const indexBytes = new Uint8Array(4);
        const view = new DataView(indexBytes.buffer);
        view.setUint32(0, childIndex + constants_1.BIP_32_HARDENED_OFFSET, false);
        return (0, utils_1.concatBytes)([new Uint8Array([0]), privateKey, indexBytes]);
    }
    // Normal child
    const parentPublicKey = await curve.getPublicKey(privateKey, true);
    return derivePublicExtension({ parentPublicKey, childIndex });
}
async function derivePublicExtension({ parentPublicKey, childIndex, }) {
    const indexBytes = new Uint8Array(4);
    const view = new DataView(indexBytes.buffer);
    view.setUint32(0, childIndex, false);
    return (0, utils_1.concatBytes)([parentPublicKey, indexBytes]);
}
/**
 * Add a tweak to the private key: `(privateKey + tweak) % n`.
 *
 * @param privateKeyBytes - The private key as 32 byte Uint8Array.
 * @param tweakBytes - The tweak as 32 byte Uint8Array.
 * @param curve - The curve to use.
 * @throws If the private key or tweak is invalid.
 * @returns The private key with the tweak added to it.
 */
function privateAdd(privateKeyBytes, tweakBytes, curve) {
    const privateKey = (0, utils_1.bytesToBigInt)(privateKeyBytes);
    const tweak = (0, utils_1.bytesToBigInt)(tweakBytes);
    if (tweak >= curve.curve.n) {
        throw new Error('Invalid tweak: Tweak is larger than the curve order.');
    }
    const added = (0, curves_1.mod)(privateKey + tweak, curve.curve.n);
    const bytes = (0, utils_1.hexToBytes)(added.toString(16).padStart(64, '0'));
    if (!curve.isValidPrivateKey(bytes)) {
        throw new Error('Invalid private key or tweak: The resulting private key is invalid.');
    }
    return bytes;
}
exports.privateAdd = privateAdd;
/**
 * @param options
 * @param options.privateKey
 * @param options.chainCode
 * @param options.secretExtension
 */
async function generateKey({ privateKey, chainCode, secretExtension, curve, }) {
    const entropy = (0, hmac_1.hmac)(sha512_1.sha512, chainCode, secretExtension);
    const keyMaterial = entropy.slice(0, 32);
    const childChainCode = entropy.slice(32);
    // If curve is ed25519: The returned child key ki is parse256(IL).
    // https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#private-parent-key--private-child-key
    if (curve.name === 'ed25519') {
        const publicKey = await curve.getPublicKey(keyMaterial);
        return { privateKey: keyMaterial, publicKey, chainCode: childChainCode };
    }
    const childPrivateKey = privateAdd(privateKey, keyMaterial, curve);
    const publicKey = await curve.getPublicKey(childPrivateKey);
    return { privateKey: childPrivateKey, publicKey, chainCode: childChainCode };
}
function generatePublicKey({ publicKey, chainCode, publicExtension, curve, }) {
    const entropy = (0, hmac_1.hmac)(sha512_1.sha512, chainCode, publicExtension);
    const keyMaterial = entropy.slice(0, 32);
    const childChainCode = entropy.slice(32);
    // This function may fail if the resulting key is invalid.
    const childPublicKey = curve.publicAdd(publicKey, keyMaterial);
    return {
        publicKey: childPublicKey,
        chainCode: childChainCode,
    };
}
//# sourceMappingURL=bip32.js.map